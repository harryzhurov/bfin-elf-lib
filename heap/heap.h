//----------------------------------------------------------------------------
//   Zltigo memory manager
//----------------------------------------------------------------------------
#ifndef HEAP_H__
#define HEAP_H__
#include    <stdint.h>
#include    <stddef.h>
#include    <scmRTOS.h>
//----------------------------------------------------------------------------
class heap
{
public:
    // Инициализация heap (используется для системы) во встроенном RAM контроллера
    template<size_t size_items>
    heap(uint32_t (& pool)[size_items]) : heap(pool, size_items) {}

    heap(uint32_t * pool, int size_items);

    // Добавляет к heap еще один отдельно находящийся блок.
    void add(void * pool, int size );

    // Резервирует память в куче 'heap', размером 'size' байт.
    // Возвращает указатель на зарезервированную память
    // Если в куче не достаточно памяти, то возвращает NULL
    void *malloc( size_t size );

    //----------------------------------------------------------------------------
    // Освобождает зарезервированную память, на которую указывает 'ptr' в 'heap'.
    // Если указатель указывает на память, которая не была выделена ранее
    // malloc_z() или указатель 'ptr' равен 0, то ничего не происходит,
    // но не исклчен вылет на exception :(
    void free( void *ptr );

    //----------------------------------------------------------------------------
    // Информация о количестве и размерах блоков свободной и занятой памяти
    //----------------------------------------------------------------------------
    struct summary
    {
        struct info
        {
            size_t Blocks;
            size_t Block_max_size;
            size_t Size;
        }
        Used, Free;

    };
    summary info();

private:
    // Полный перебор свободных блоков с целью
    // найти свободный блок совпадающий по размеру с
    // запрашиваемым.
    static bool const USE_FULL_SCAN = 1;
    static size_t const HEAP_ALIGN = sizeof(uint32_t);

    // Memory Control Block (MCB)
    //----------------------------------------------------------------------------
    struct mcb
    {
        enum mark
        {
            FREE = 0,
            ALLOCATED,
        };
        struct type_size
        {
            size_t type:8;
            size_t size:24;
        };

        mcb *next;              // Указатель на следующий MCB
                                // mcb.next  последнего MCM всегда указывает на
                                // первый MCB.
        mcb *prev;              // Указатель на предыдущий MCB.
                                // Для первого MCB этот указатель указывает
                                // сам на себя.
        type_size ts;  	        // Размер блока памяти (в байтах)

                                // Собственно контролируемый блок памяти расположен сразу за MCB

        // разделяет текущий блок на два, возвращает указатель на новый mcb
        mcb * split(size_t size, mcb * start);
        // объединяет текущий блок со следующим
        void merge_with_next(mcb * start);

        void * pool() { return this + 1; }
    };

    //----------------------------------------------------------------------------
    // Структура-описатель кучи (тип-структура t_heap)
    //----------------------------------------------------------------------------
    mcb *start;                 // Указатель на начало heap (первый MCB)

    mcb *freemem;               // Указатель на первый свободный MCB

    OS::TMutex  Mutex;          // защита для многопоточности
};

//----------------------------------------------------------------------------
// Структура описывающая heap во встроенном RAM контроллера
extern heap Heap;
//----------------------------------------------------------------------------
#endif  // HEAP_H__
